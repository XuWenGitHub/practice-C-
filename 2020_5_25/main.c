#include"test.h"


int main(){
	//如何判断一个电脑是小端还是大端
	//小端就是：把数据的低权值字节数据，放在了低地址字节里面
	//大端就是：把数据的高权值字节数据，放在了低地址字节里面
	//int i = 1;
	//char* result = &i;
	//if (*result){
	//	printf("小端");
	//}
	//else{
	//	printf("大端");
	//}


	/*
	a,b是有符号数，输出是%d，会整形提升，a，b前面全补符号位1，所有32个1，还是-1
	c是无符号数，输出是%d，会整形提升，但是无符号数，整形提升，前面补24个0，剩下8个1，所以255
	*/
	//char a = -1;
	//signed char b = -1;
	//unsigned char c = -1;
	//printf("a=%d,b=%d,c=%d", a, b, c);	//-1,-1,255


	/*
	-128是1000 0000
	然后无符号数输出，要整形提升
	因为a类型是有符号数，整形提升，前面补1
	然后无符号输出，直接输出1111 1111 1111 1111 1111 1111 1000 0000二进制转为十进制：
	4294967168
	*/
	//char a = -128;
	//printf("%u\n", a);	//4294967168


	/*
	127:	0111 1111
	1:		0000 0001
	128:	1000 0000
	因为a类型是有符号数，整形提升，前面补符号位
	还是和上面一样，因为要整形提升，补符号位1
	然后无符号输出，直接输出1111 1111 1111 1111 1111 1111 1000 0000二进制转为十进制：
	4294967168
	*/
	//char a = 128;
	//printf("%u\n", a);	//4294967168


	/*
	按照补码的形式进行运算，最后格式化成有符号数
	*/
	//int i = -20;
	//unsigned int j = 10;
	//printf("%d\n", i + j);


	/*
	死循环：
	i是无符号数，永远都会大于等于0
	当1等于-1，32个1，然后无符号读是4294967295，然后就死循环了...
	*/
	/*unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
	}*/


	/*
	strlen,遇到/0就停止，也就是遇到0，就停止，但0不包括在内
	-1 -> -128	128个数字
	127 -> 0	128个数字
	加起来为256个数字，但是0，不能算在长度里面，所有减一，长度为255
	*/
	/*char a[1000];
	int i;
	for (i = 0; i<1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));*/

	/*
	
	char类型取值范围：-128 -> 127
	因为无符号数，全是大于等于0的数 所以取值范围[0,255]
	当i为256时，不满足条件
	但是256为 1 0000 0000
	char只有一字节，八比特位，发生截断，i就又变为0了，所有死循环
	*/
	unsigned char i = 0;
	for (i = 0; i <= 255; i++)
	{
		printf("%d\n", i);
		printf("hello world\n");
	}
	system("pause");
}